---
layout: post
title: "OTA升级流程"
date:   2020-09-08
tags: [geek]
comments: true
author: thomaszeng
---

OTA升级流程,客户端只需调用RecoverySystem.installPackage(Context context,File packageFile)方法，将OTA包的路径传递到installPackage方法中，Android系统将重启，然后进行自动升级。
这一过程，在应用层要处理的逻辑比较简单，而底层的实现原理比较复杂，由于近期在做Pad升级相关的功能，所以打算对OTA升级进行一个简单的总结。

## 第一步：准备升级

我们先在源码中查找到RecoverySystem.java所在的路径，位于 frameworks/base/core/java/android/os/RecoverySystem.java

```
在应用层下载OTA升级包后，会调用RecoverySystem.installPackage(Context context,File packageFile)方法
来发起安装过程，这个过程的主要原理，实际上是王/cache/recovery/command写入OTA升级包的路径，然后重启到recovery模式，
仅此而已。
```
```
public static void installPackage(Context context, File packageFile)
    throws IOException {
    final String filenameArg = "--update_package=" + filename + "\n";
            final String localeArg = "--locale=" + Locale.getDefault().toLanguageTag() + "\n";
            final String securityArg = "--security\n";

            String command = filenameArg + localeArg;
            if (securityUpdate) {
                command += securityArg;
            }    

    RecoverySystem rs = (RecoverySystem) context.getSystemService(
                    Context.RECOVERY_SERVICE);
            if (!rs.setupBcb(command)) {//向BCB结构体command中写入
                throw new IOException("Setup BCB failed");
            }

            // Having set up the BCB (bootloader control block), go ahead and reboot
            PowerManager pm = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
            String reason = PowerManager.REBOOT_RECOVERY_UPDATE;

            // On TV, reboot quiescently if the screen is off
            if (context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_LEANBACK)) {
                WindowManager wm = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
                if (wm.getDefaultDisplay().getState() != Display.STATE_ON) {
                    reason += ",quiescent";
                }
            }
            pm.reboot(reason);//向BCB结构体重的recovery写入
}
```
```
struct bootloader_message {
    char command[32];
    char status[32];
    char recovery[768];

    // The 'recovery' field used to be 1024 bytes.  It has only ever
    // been used to store the recovery command line, so 768 bytes
    // should be plenty.  We carve off the last 256 bytes to store the
    // stage string (for multistage packages) and possible future
    // expansion.
    char stage[32];

    // The 'reserved' field used to be 224 bytes when it was initially
    // carved off from the 1024-byte recovery field. Bump it up to
    // 1184-byte so that the entire bootloader_message struct rounds up
    // to 2048-byte.
    char reserved[1184];
};
```
```
bootloader_message结构体包含5个字段，我们关注前面三个
command字段中存储的是命令，它有一下几个可能值：
*boot-recovery:系统将启动进入Recovery模式
*update-radia或者update-hboot:系统将启动进入更新firmware的模式，这个更新过程由bootloader完成
*NULL:空值，系统启动进入Main System主系统，正常启动
status字段存储的是更新结果。更新结束后，由Recovery或者Bootloader将更新结果写入这个字段中
recovery存储升级包路径信息"-update_package=/cache/recovery/update.zip"等，参数之间以"\n"分割
```

## 第二步：系统重启进入Recovery模式，进行升级操作
```
重启进入升级主要流程：
1.系统重启进入Recovery模式。读取BCB的command,读取到"boot-recovery"后，加载recovery.img,启动recovery.
2.在install.cpp进行升级操作
3.try_update_binary执行升级脚本
4.调用finish_recovery方法，清除BCB信息，重启
```
```
说明1.系统重启进入Recovery模式
系统重启时会判断/cache/recovery目录下是否有command文件，如果存在就进入recovery模式，否则正常启动
进到recovery模式下，将执行recovery.cpp的main函数，下面贴出关键代码
```
```
... ...
while ((arg = getopt_long(argc, argv, "", OPTIONS, NULL)) != -1) {  
    switch (arg) {  
    case 's': send_intent = optarg; break;  
    case 'u': update_package = optarg; break;  
    ... ... 
} 
```
```
在install.cpp进行升级操作,在main函数最终会调用install_package()方法
```
```
... ...
if (update_package != NULL) {  
    status = install_package(update_package, &wipe_cache, TEMPORARY_INSTALL_FILE, true);  
    ... ...
} 
    ... ...
```
```
具体升级过程都是在install.cpp中执行的，在看看install_package方法
```
```
int install_package(const char* path, int* wipe_cache, const char* install_file,  
                bool needs_mount)  
{  
    ... ...
    if (setup_install_mounts() != 0) {  
        ... ...
    } else {  
        result = really_install_package(path, wipe_cache, needs_mount);  
    }
    ... ...
}  
```
```
install_package方法中创建了log文件(记录升级报错的信息)，然后调用really_install_package方法
```
```

static int really_install_package(const char *path, int* wipe_cache, bool needs_mount)  
{  
    ... ...
    // 装入签名文件
    Certificate* loadedKeys = load_keys(PUBLIC_KEYS_FILE, &numKeys);
    ... ...
    // 验证签名
    err = verify_file(map.addr, map.length, loadedKeys, numKeys);
    ... ...
    // 打开升级包  
    err = mzOpenZipArchive(map.addr, map.length, &zip);
    ... ... 
    // 执行升级脚本文件，开始升级  
    int result = try_update_binary(path, &zip, wipe_cache);
    ... ...
} 
```
```
really_install_package方法中，首先验证签名，在读取升级包，然后在进行调用try_update_binary方法升级
```
```
3.try_update_binary执行升级脚本
```
```
static int try_update_binary(const char *path, ZipArchive *zip, int* wipe_cache) {
 
    const ZipEntry* binary_entry = mzFindZipEntry(zip, ASSUMED_UPDATE_BINARY_NAME);
    ... ...
    const char* binary = "/tmp/update_binary";
    unlink(binary);
    int fd = creat(binary, 0755); 
    ... ...
    //将升级包里面的update_binary解压到/tmp/update_binary
    bool ok = mzExtractZipEntryToFile(zip, binary_entry, fd);
    ... ...
 
    const char** args = (const char**)malloc(sizeof(char*) * 5);
    args[0] = binary; //update_binary存放路径
    args[1] = EXPAND(RECOVERY_API_VERSION);  // Recovery版本号
    char* temp = (char*)malloc(10);
    sprintf(temp, "%d", pipefd[1]);
    args[2] = temp;
    args[3] = (char*)path; //升级包存放路径
    args[4] = NULL;
 
    pid_t pid = fork();//fork一个子进程
    if (pid == 0) {
        close(pipefd[0]);
        //子进程调用update-binary执行升级操作
        execv(binary, (char* const*)args);
        fprintf(stdout, "E:Can't run %s (%s)\n", binary, strerror(errno));
        _exit(-1);
    }
    //父进程负责接受子进程发送的命令去更新ui显示 
    ... ...
    int status;
    waitpid(pid, &status, 0);
    if (!WIFEXITED(status) || WEXITSTATUS(status) != 0) {
        //安装失败，返回INSTALL_ERROR
        return INSTALL_ERROR;
    }
     //安装成功，返回INSTALL_SUCCESS
    return INSTALL_SUCCESS;
}
```
```
4.调用finish_recovery方法，清楚BCB信息，重启
OTA升级成功，清空misc分区(BCB置零)，并将保存到北荣系统的升级日志/tmp/recovery.log保存到/cache/recovery/last_log。重启设备进入Main System,升级完成。
```

